#include "db.h"

DB::DB(char* filePath,char* name)
{
	//allocate a file for the database, fill in the major strcutres
	error=false;
	connected=false;
	errorCode="";

	dbName=new char[strlen(name)+1];
	this->filePath=new char[strlen(filePath)+1];

	strcpy(this->filePath,filePath);	
	strcpy(dbName,name);


	dbFile=fopen(filePath,"w");
	if(dbFile==NULL){
		error=true;
		errorCode="couldn't alloacte data file";
		return;
	}

	char* content=new char[200]; //buffer
	strcpy(content,"<DATABASE> ");
	strcat(content,dbName);
	strcat(content,"\n\t<METADATA>\n\t</METADATA>\n");
	strcat(content,"\t<TABLES>\n\t</TABLES>\n</DATABASE>");	

	fputs(content,dbFile);

	delete []content; //free buffer
	fclose(dbFile);
	
}

//this method takes existing database file and creates a database object
//this method will not check the file layout assuming it was generated by this program or has the
//prober layout: if layout isn't right all methods will fail
DB* DB::createFromFile(char* filePath){
	FILE* file=fopen(filePath,"r");
	//now read the first line to get the database name
	if(file==NULL)
		return NULL;
	
	char* line=new char[100];
	fgets(line,100,file);
	char* name=getWord(line,2);
	DB* db=new DB();

	db->error=false;
	db->connected=false;
	db->errorCode="";

	db->dbName=new char[strlen(name)+1];
	db->filePath=new char[strlen(filePath)+1];

	strcpy(db->filePath,filePath);	
	strcpy(db->dbName,name);

	fclose(file);
	return db;
}

DB::~DB(void)
{
	delete [] dbName;
	delete [] filePath;
}

//create empty table as a start
bool DB::createTable(char* tableName){
	//we must check for existing items with the same name, new table added to the end
	if(!connected){
		error=true;
		errorCode="data base is offline";
		return false;
	}
	FILE* temp=tmpfile();
	
	if(temp==NULL){
		error=true;
		errorCode="couldn't create a temporary file";
		return false;
	}

	dbFile=fopen(filePath,"r");
	
	char* line=new char[500]; //500 chars max line
	char* newLine=new char[500];
	
	//form the new line:		<TABLE> tableName
	strcpy(newLine,"\t\t<TABLE> ");
	strcat(newLine,tableName);
	strcat(newLine,"\n");

	while(!feof(dbFile)){
		fgets(line,500,dbFile); //check error here
		//check for existing

		if(strcmp(line,newLine)==0){
			error=true;
			errorCode="table with the same name already exists";
			delete []line;
			delete []newLine;
			fclose(temp);
			fclose(dbFile);
			return false;
		}
		
		//now check if we reached the end of tables </TABLES>
		if(strcmp(line,"\t</TABLES>\n")==0){ //create the new table entry
			strcat(newLine,"\t\t\t<COLUMNS>\n\t\t\t</COLUMNS>\n\t\t\t<ROWS>\n\t\t\t</ROWS>\n\t\t</TABLE>\n");
			fputs(newLine,temp);
		}
		fputs(line,temp);
	}
	fclose(dbFile);
	dbFile=fopen(filePath,"w");

	//now recopy to the original file
	fseek(temp,0,SEEK_SET);
	while(!feof(temp)){
		fgets(line,500,temp); //check error here
		fputs(line,dbFile);
	}
	
	fclose(temp); //temp files are deleted automatically by closing them
	fclose(dbFile);

	delete [] line;
	delete [] newLine;
	return true;
}

//insert a new column: search the specified table entry, search all columns
//in that table for columns with the same name, then insert
bool DB::createCol(char* tableName,char* colName,char* dataType,char* constraint){
	//check data type
	if(!connected){
		error=true;
		errorCode="data base is offline";
		return false;
	}
	char* datatypes="string int double";
	if(contains(datatypes,dataType,", \t\n")==-1){
		error=true;
		errorCode="unrecognized data type";
		return false;
	}

	//check constarint
	char* cons="PK UK NULL";
	if(contains(cons,constraint,", \t\n")==-1){
		error=true;
		errorCode="unrecognized constraint";
		return false;
	}

	FILE* temp=tmpfile();
	
	if(temp==NULL){
		error=true;
		errorCode="couldn't create a temporary file";
		return false;
	}

	dbFile=fopen(filePath,"r");

	char* line=new char[500]; //500 chars max line
	char* newLine=new char[500];
	bool inserted=false;

	//form the new line:		<TABLE> tableName
	strcpy(newLine,"\t\t<TABLE> ");
	strcat(newLine,tableName);
	strcat(newLine,"\n");

	while(!feof(dbFile)){
		fgets(line,500,dbFile); 
		//check for existing
		if(!inserted){
			if(strcmp(line,newLine)==0){ //we fount table entry, search columns
				fputs(line,temp);
				strcpy(newLine,"\t\t\t\t<COLUMN> ");
				strcat(newLine,colName);  //search for <COLUMN> colName
				while(!feof(dbFile) && !inserted){
					//check existing names
					fgets(line,500,dbFile);

					if(strncmp(line,newLine,strlen(newLine))==0){ //<Column> name type cons </Column>
						error=true;
						errorCode="column with the same name already exists";
						delete []line;
						delete []newLine;
						fclose(temp);
						fclose(dbFile);
						return false;
					}

					//we can add a check for PK and UK 
					if(strcmp(constraint,"PK")==0 && contains(line,constraint)!=-1){
						//out
						error=true;
						errorCode="primary key already defined";
						delete []line;
						delete []newLine;
						fclose(temp);
						fclose(dbFile);
						return false;
					}
					
					if(strcmp(line,"\t\t\t</COLUMNS>\n")==0){ //we are at </COLUMNS> tag, insert the column 
						strcpy(newLine,"\t\t\t\t<COLUMN> ");
						strcat(newLine,colName);
						strcat(newLine," ");
						strcat(newLine,dataType);
						strcat(newLine," ");
						strcat(newLine,constraint);
						strcat(newLine," </COLUMN>\n");
						fputs(newLine,temp);
						inserted=true;
					}
					fputs(line,temp);

				}
			}
			else
				fputs(line,temp);
		}
		else
			fputs(line,temp);
	}
	fclose(dbFile);
	dbFile=fopen(filePath,"w");

	//now recopy to the original file
	fseek(temp,0,SEEK_SET);
	while(!feof(temp)){
		fgets(line,500,temp); //check error here
		fputs(line,dbFile);
	}
	
	fclose(temp); //temp files are deleted automatically by closing them
	fclose(dbFile);

	delete [] line;
	delete [] newLine;
	return true;

	return true;
}

// ckeck if word is inside this line: return it's index(starts from 1) or -1 for none
int DB::contains(const char* line, char* word,char* sep)
{
	char* token;
	int index=1;
	//duplicate input line
	int len=strlen(line);
	char* temp=new char[len+1];
	temp[len]='\0';
	strcpy(temp,line);

	token=strtok(temp,sep); //space and tab
	while(token!=NULL){
		if(strcmp(token,word)==0)
			return index;
		token=strtok(NULL,sep);
		++index;
	}
	return -1;
}


char* DB::getWord(const char* line,int index,char* sep){
	char* token;
	//duplicate input line
	int len=strlen(line);
	int i=1;
	char* temp=new char[len+1];
	strcpy(temp,line);
	temp[len]='\0';

	token=strtok(temp,sep); //space and tab
	while(token!=NULL && i<index){
		token=strtok(NULL,sep);
		i++;
	}
	return token;

}

bool DB::checkType(char* cell,char* type){
	if(type==NULL || cell==NULL)
		return false;
	if(strcmp(type,"string")==0){
		//check double cotation marks
		//but we'll allow strings with\without ""
		return true;

	}

	if(strcmp(type,"int")==0){
		char* stopScan;
		strtol(cell,&stopScan,10); //long integer
		if(strlen(stopScan)==0)
			return true;
		else
			return false;
	}
	if(strcmp(type,"double")==0){
		char* stopScan;
		strtod(cell,&stopScan); //long integer
		if(strlen(stopScan)==0)
			return true;
		else
			return false;
	}

	return false;
}

// i.e insertRow("table1","323 4343 ererr 334.33");
bool DB::insertRow(char* table,char* data){
	/*we'll check if data is cmpatible with columns
	  - find the table entry
	  - keep the column datatypes in save
	  - match data with column datatypes
	  - missing in number causes filling other columns with NULL if allowed
	  - check existing data for PK or Unique condition
	  - finally insert the row
	*/
	if(!connected){
		error=true;
		errorCode="data base is offline";
		return false;
	}
	FILE* temp=tmpfile();
	
	if(temp==NULL){
		error=true;
		errorCode="couldn't create a temporary file";
		return false;
	}

	dbFile=fopen(filePath,"r");

	char* line=new char[500]; //500 chars max line
	char* newLine=new char[500];
	char* datatypes=new char[500];
	bool inserted=false;

	datatypes[0]='\0';

	//form the new line:		<TABLE> tableName to get the table entry
	strcpy(newLine,"\t\t<TABLE> ");
	strcat(newLine,table);
	strcat(newLine,"\n");
	while(!feof(dbFile)){
		fgets(line,500,dbFile); 
		//check for existing
		if(strcmp(line,newLine)==0){ //we fount table entry, search columns
			fputs(line,temp);
			//now keep columns datatypes in order
			bool endCol=false;;
			while(!feof(dbFile) && !endCol){
				fgets(line,500,dbFile);
				//check tag:
				char* tag=getWord(line,1);
				if(strcmp(tag,"<COLUMN>")==0){ //save data type and constraint
					strcat(datatypes,getWord(line,3)); //the third index: <COLUMN> name datatype constraint
					strcat(datatypes," ");
					strcat(datatypes,getWord(line,4));
					strcat(datatypes," ");
				}
				if(strcmp(tag,"</COLUMNS>")==0)
					endCol=true;
				
				fputs(line,temp);
			}
			fgets(line,500,dbFile); // <ROWS> we can skip this
			fputs(line,temp);
			//check data upon column types
			if(!checkData2Col(datatypes,data)){
				
				delete [] line;
				delete [] newLine;
				delete []datatypes;

				fclose(temp);
				fclose(dbFile);
				error=true;
				errorCode="row data doesn't match table column's data types ";

				return false;
			}
			//now scan existing rows and check for( Unique key, Primary Key conditions)
			//until we reach the <\ROWS> tag
			while(!feof(dbFile)){
				fgets(line,500,dbFile); //we can add check for <ROW> tag here:
				//this will make things less dependant on file layout
				if(!checkConstraints(line,data,datatypes)){ 
					delete [] line;
					delete [] newLine;
					delete []datatypes;

					fclose(temp);
					fclose(dbFile);
					error=true;
					errorCode="primary or uniqe key constraint validation, can't insert the row";
					return false;		
				}
				if(strcmp(getWord(line,1),"</ROWS>")==0){ //the end of rows
					//insert our row
					strcpy(newLine,"\t\t\t\t<ROW> ");
					//if data contains new lines: we must skip them
					char* word=getWord(data,1);
					int i=1;
					while(word != NULL){
						strcat(newLine,word);
						strcat(newLine," ");
						word=getWord(data,++i);						
					}
					//strcat(newLine,data);
					strcat(newLine," </ROW>\n");
					fputs(newLine,temp);
					fputs(line,temp);
					break;
				}
				fputs(line,temp);
			}
			//copy the rest of data safely:

			while(!feof(dbFile)){
				fgets(line,500,dbFile);
				fputs(line,temp);
			}
			break; //the outer while loop
		}
		else
			fputs(line,temp);
	}
	fclose(dbFile);
	dbFile=fopen(filePath,"w");

	//now recopy to the original file
	fseek(temp,0,SEEK_SET);
	while(!feof(temp)){
		fgets(line,500,temp); //check error here
		fputs(line,dbFile);
	}
	
	fclose(temp); //temp files are deleted automatically by closing them
	fclose(dbFile);

	delete [] line;
	delete [] newLine;
	delete []datatypes;

	return true;
}

//this method will compare each datacell in the row if it matches th data in the column structre
//datatypes has the form: datatype constarint datatype constarint... 
//Uk, NULL constarints allow a data cell to be NULL
bool DB::checkData2Col(char* datatypes,char* rowData){
	int index=1;
	char* type;
	char* cell;
	char* cons;
	while(true){
		type=getWord(datatypes,index*2-1);
		cons=getWord(datatypes,index*2);
		cell=getWord(rowData,index); 
		if(type==NULL && cell==NULL) //check complete
			return true;
		if(type==NULL || cell==NULL) //once data chain has more or less cells than supposed to be
			return false;

		if((strcmp(cons,"UK")==0 || strcmp(cons,"NULL")==0)&& strcmp(cell,"NULL")==0) //accept
			++index;
		else{
            if(checkType(cell,type))
				++index;
			else
				return false;
		}

	}
}

//row has the form: <ROW> col1Data col2Data ...</ROW>
//new row has the form:  col1data col2data ...
//datatypes has the form: datatype cons datatype cons: cons= PK|UK|NULL
bool DB::checkConstraints(char* row ,char* newRow,char* datatypes){
	int index=1;
	char* cell;
	char* newCell;
	char* cons;
	while(true){
		cell=getWord(row,index+1);
		newCell=getWord(newRow,index);
		cons=getWord(datatypes,index*2);
		if(newCell==NULL || cell==NULL)
			return true;
		if((strcmp(cell,newCell)==0)&&(strcmp(cons,"PK")==0 || strcmp(cons,"UK")==0))
			return false;
		else
			++index;			

	}
}

char* DB::getTableNames(){
	if(!connected){
		error=true;
		errorCode="data base is offline";
		return " \0";
	}
	//find all <TABLE> tags
	dbFile=fopen(filePath,"r");
	char* names=new char[2000]; //we can add these constants as global capabilities
	char* line=new char[500];

	names[0]='\0';
	while(!feof(dbFile)){
		fgets(line,500,dbFile);
		if(strcmp(getWord(line,1),"<TABLE>")==0){ //table entry
			strcat(names,getWord(line,2));
			strcat(names,"\n");
		}
	}
	delete []line;
	fclose(dbFile);

	return names;
}

char* DB::getTableDefinition(char* tableName){
	if(!connected){
		error=true;
		errorCode="data base is offline";
		return "";
	}
	//find table entry then get data between <COLUMNS> </COLUMNS>
	char * def=new char[5000];

	dbFile=fopen(filePath,"r");
	char* line=new char[500];

	strcpy(def,tableName);
	strcat(def," column definition: NAME,TYPE,CONSTRAINT\n");
	while(!feof(dbFile)){
		fgets(line,500,dbFile);
		if(strcmp(getWord(line,1),"<TABLE>")==0){ //table entry
			//check table name
			if(strcmp(getWord(line,2),tableName)==0){ //this is our table
				fgets(line,500,dbFile); //skip <COLUMNS> tag
				while(!feof(dbFile)){
					fgets(line,500,dbFile);
					if(strcmp(getWord(line,1),"</COLUMNS>")==0){ //end of ColDef
						delete [] line;
						fclose(dbFile);
						return def; //we'll always reach here unless file is corrupted
					}
					strcat(def,line);
				}
			}

		}
	}
	delete []line;  //we'll never reach here if file is not corrupted
	fclose(dbFile);

	return def;
}

char* DB::getTableData(char* tableName){
	if(!connected){
		error=true;
		errorCode="data base is offline";
		return "";
	}
	//find table entry then get data between <ROWS> </ROWS>
	char* rows=new char[50000]; //50 KB of data, increase this for larger data retrieval
	dbFile=fopen(filePath,"r");
	char* line=new char[500];

	strcpy(rows,tableName);
	strcat(rows," data:");
	while(!feof(dbFile)){
		fgets(line,500,dbFile);
		if(strcmp(getWord(line,1),"<TABLE>")==0){ //table entry
			//check table name
			if(strcmp(getWord(line,2),tableName)==0){ //this is our table
				fgets(line,500,dbFile); //skip <COLUMNS> tag
				//get column names
				while(!feof(dbFile)){
					//save column names
					fgets(line,500,dbFile);
					if(strcmp(getWord(line,1),"</COLUMNS>")==0)
						break;
					if(strcmp(getWord(line,1),"<COLUMN>")==0){
						strcat(rows,getWord(line,2));
						strcat(rows,"  ");
					}
				}
				char* tag;
				strcat(rows,"\n");
				while(!feof(dbFile)){
					fgets(line,500,dbFile);
					tag=getWord(line,1);
					if(strcmp(tag,"<ROW>")==0) //get row
						strcat(rows,line);
					if(strcmp(tag,"</COLUMNS>")==0){ //end of ColDef
						delete [] line;
						fclose(dbFile);
						return rows; //we'll always reach here unless file is corrupted
					}
				}
			}

		}
	}
	delete []line;  //we'll never reach here if file is not corrupted
	fclose(dbFile);

	return rows;
}

bool DB::dropTable(char* tableName){
	if(!connected){
		error=true;
		errorCode="data base is offline";
		return false;
	}
	//find table entry, skip it
	FILE* temp=tmpfile();
	
	if(temp==NULL){
		error=true;
		errorCode="couldn't create a temporary file";
		return false;
	}

	dbFile=fopen(filePath,"r");

	bool found=false;
	char* line=new char[500]; //500 chars max line
	
	while(!feof(dbFile)){
		fgets(line,500,dbFile);
		if(strcmp(getWord(line,1),"<TABLE>")==0){ // a table entry
			if(strcmp(getWord(line,2),tableName)==0){ //this is our table
				while(!feof(dbFile)){ //skip the lines
					fgets(line,500,dbFile);
					if(strcmp(getWord(line,1),"</TABLE>")==0) //the end of our table
						break;
				}
				while(!feof(dbFile)){ //copy the rest: this while loop is faster than using the outer loop
					fgets(line,500,dbFile);
					fputs(line,temp);
				}
				found=true;
				break; //break the outer loop
			}
		}
		fputs(line,temp);
	}

	fclose(dbFile);
	dbFile=fopen(filePath,"w");

	//now recopy to the original file
	fseek(temp,0,SEEK_SET);
	while(!feof(temp)){
		fgets(line,500,temp); //check error here
		fputs(line,dbFile);
	}
	
	fclose(temp); //temp files are deleted automatically by closing them
	fclose(dbFile);
	delete []line;
	if(found)
		return true;
	else{
		error=true;
		errorCode="couldn't drop table, because it doesn't exist";
		return false;
	}
}

bool DB::deleteRow(char* tableName,int id){
	if(!connected){
		error=true;
		errorCode="data base is offline";
		return false;
	}
	FILE* temp=tmpfile();
	
	if(temp==NULL){
		error=true;
		errorCode="couldn't create a temporary file";
		return false;
	}

	dbFile=fopen(filePath,"r");

	bool found=false;
	int rowID=1;
	char* line=new char[500]; //500 chars max line
	
	while(!feof(dbFile)){
		fgets(line,500,dbFile);
		if(strcmp(getWord(line,1),"<TABLE>")==0){ // a table entry
			if(strcmp(getWord(line,2),tableName)==0){ //this is our table
				fputs(line,temp);
				while(!feof(dbFile)){ //find the row
					fgets(line,500,dbFile);
					if(strcmp(getWord(line,1),"</ROWS>")==0){ //row doesn't exist
						fputs(line,temp);
						break;
					}
					if(strcmp(getWord(line,1),"<ROW>")==0){ //a row found: increment rowID
						if(rowID==id){ //skip this row
							found=true;
							break;
						}
						++rowID;
					}
					fputs(line,temp);
				}
				while(!feof(dbFile)){ //copy the rest: this while loop is faster than using the outer loop
					fgets(line,500,dbFile);
					fputs(line,temp);
				}
				break; //break the outer loop
			}
		}
		fputs(line,temp);
	}

	fclose(dbFile);
	dbFile=fopen(filePath,"w");

	//now recopy to the original file
	fseek(temp,0,SEEK_SET);
	while(!feof(temp)){
		fgets(line,500,temp); //check error here
		fputs(line,dbFile);
	}
	
	fclose(temp); //temp files are deleted automatically by closing them
	fclose(dbFile);
	delete []line;
	if(found)
		return true;
	else{
		error=true;
		errorCode="couldn't delete row,index out of range";
		return false;
	}
}

char* DB::getDBName(){
	char* name=new char[strlen(dbName)+1];
	strcpy(name,dbName);
	return name;
}

char* DB::select(char* colList,char* tableName,char* cond){

	char* data=new char[50000]; //50 KB of data
	char* line=new char[200];
	char* colNames=new char[500]; 
	char* row=new char[500];
	//will hold the table col names to match with colList to get the col index in the row
	
	data[0]='\0';
	row[0]='\0';
	colNames[0]='\0';
	row[0]='\0';

	dbFile=fopen(filePath,"r");
	while(!feof(dbFile)){
		//find table entry
		fgets(line,200,dbFile);
		if(strcmp(getWord(line,1),"<TABLE>")==0){ //a table enrty
			//check if it's our table
			if(strcmp(getWord(line,2),tableName)==0){ //tableName found
				//save column names, datatypes
				while(!feof(dbFile)){
					fgets(line,200,dbFile);
					if(strcmp(getWord(line,1),"</COLUMNS>")==0) //COLUMNS entry end
						break;
					if(strcmp(getWord(line,1),"<COLUMN>")==0){ //column entry
						strcat(colNames,getWord(line,2)); //col name
						strcat(colNames," ");
						strcat(colNames,getWord(line,3)); //col data type
						strcat(colNames," ");
					}
				}

				//now we got the columns names and datatypes
				//check colList to colNames(for input query errors)
				//also check for * instead of colList

				
				int i=1;
				char* temp=getWord(colList,i);
				while(temp!=NULL){
					if(contains(colNames,temp)==-1){
						error=true;
						errorCode="column list contains unrecoginized names\n";
						fclose(dbFile);
						delete []data;
						delete []line;
						delete []colNames;
						delete []row;
						return NULL;
					}
					temp=getWord(colList,++i);
				}

				if(i==1){ //not supposed to happen: no columns in colList
					error=true;
					errorCode="column list is empty";
					fclose(dbFile);
					delete []data;
					delete []line;
					delete []colNames;
					delete []row;
					return NULL;
				}
				
				

				//column list is acceptable
				//now map colList items to indexes in the ROW data
				--i;
				int* colIndex=new int[i]; // //now i holds the number of columns in the query
				//fill the index array
				int j=0;
				
				
				while(j<i){
					
					++j;
					colIndex[j-1]=contains(colNames,getWord(colList,j))/2+1; 
					//colNames: colName dataType colName dattype, we need colName as it exists in the ROW data
				}

				

				//now get the Row data
				while(!feof(dbFile)){
					fgets(line,200,dbFile);
					if(strcmp(getWord(line,1),"</ROWS>")==0){ //we are done
						fclose(dbFile);
						delete []line;
						delete []colNames;
						delete []row;
						return data;
					}
					
					if(strcmp(getWord(line,1),"<ROW>")==0){ //a row entry
						//get row data that matchs the calculated indexes
						//we'll check for the condition later
						if(checkCond(cond,colNames,line)){
							j=0;
							row[0]='\0';
							
							while(j<i){
								strcat(row,getWord(line,colIndex[j]+1)); //+1 for the <ROW> tag
								strcat(row," ");
								++j;
							}
							//add the row to the final data
							strcat(data,row);
							strcat(data,"\n");	
						}
					}
					
				}
				
				delete [] colIndex;
			}
		}
	}	

	//table doesn't exists
	error=true;
	errorCode="table name not found";

	fclose(dbFile);
	delete []data;
	delete []line;
	delete []colNames;
	delete []row;

	return NULL;
	
	
}

//cond: colName>|<|=val
//colNames: colName datatype..
//row: <ROW> col1Data...</ROW>
bool DB::checkCond(char* cond,char* colNames,char* row){
	if(cond==NULL) //no condition
		return true;
	//cout<<cond;
	char* colName=getWord(cond,1,"><=");
	char* val=getWord(cond,2,"<>=");
	if(strlen(colName)==strlen(cond))
		return false;
	char op=cond[strlen(colName)];

	if(colName==NULL || val==NULL)
		return false; 

	//get data piece relative to the condition
	int index=contains(colNames,colName);
	if(index==-1)
		return false;

	char* type=getWord(colNames,index+1); //datatype follows the col name
	index=index/2+1; //the real index
	char* data=getWord(row,index+1); //<ROW> coldata
	
	if(!checkType(val,type))
		return false;

	//now check condition

//	cout<<"colname:"<<colName<<"  op:"<<op<<"  val:"<<val<<"  type:"<<type<<"  data:"<<data<<endl;

	if(strcmp(type,"string")==0){
		if(op=='>'){
				if(strcmp(data,val)>0)
				return true;
			else
				return false;
		}
		if(op=='<'){
			if(strcmp(data,val)<0)
				return true;
			else
				return false;
			}
		if(op=='='){
			if(strcmp(data,val)==0)
				return true;
			else
				return false;
		}
		return false;
	}


	if(strcmp(type,"int")==0){
		char* stopScan;
		long vali=strtol(val,&stopScan,10); //long integer
		long datai=strtol(data,&stopScan,10);
		
		if(op=='>'){
			if(datai>vali)
				return true;
			else
				return false;
		}
		if(op=='<'){
			if(datai<vali)
				return true;
			else
				return false;
		}
		if(op=='='){		
			if(datai==vali)
				return true;
			else
				return false;
		}
		return false;
	}
	if(strcmp(type,"double")==0){
		char* stopScan;
		double vald=strtod(val,&stopScan); //long integer
		double datad=strtod(data,&stopScan);
		if(op=='>'){
			if(datad>vald)
				return true;
			else
				return false;
		}
		if(op=='<'){
			if(datad<vald)
				return true;
			else
				return false;
		}
		if(op=='='){
			if(datad==vald)
				return true;
			else
			return false;
		}
		return false;
	}
	return false;
}

char* DB::query(char* queryStr){
	//for now only simple select is available
	char* colList=getWord(queryStr,2,"; \n\t");
	char* tabName=getWord(queryStr,4,"; \n\t");
	if(colList==NULL || tabName==NULL)
		return NULL;
	char* cond=getWord(queryStr,6,"; \t\n");
	return select(colList,tabName,cond);
}

/* you must replace all temporary buffers as a member data
	then use one free method 
*/